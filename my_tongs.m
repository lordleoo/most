function [muffin,str_final] = my_tongs(full_idx,field,name,dim,idx)
% A "tong" is a kitchen/table tool for picking up food pieces
% [muffin,str_final] = my_tongs(full_idx,field,name,dim,idx)
% my_tongs provides the index of a variable, linear constraint or cost parameter
% which meets the criteria provided in the second, third, fourth and 5th inputs
% All inputs are required
% 
% Inputs:
% full_idx generated by the function get_full_idx written also by B.M.
% field: 'var', 'lin', or 'qdc'. Only one choice is allowed as a character vector, not a cell
% name: name of variable, constraint or cost parameter
%       Examples: 'Pg','Sm', 'Pc',' Psc', 'Psd'
%       only one choice is allowed. Input must be a character vector, not a cell
% dim:  in full_idx.full_list last column, a string such as Pg(1,1,1,1) 
%       identifies a variable Pg with four dimensions.
%       input "dim" is in which dimension you're searching for the value provided by 5th input idx
%       if dim<0, like the python convention, i take the last (from end and back)
%       for example, dim = -1 means take the last index;
%       dim = -2 means take end-1
%       This comes handy because some variables are NOT 4 dimensions, but only 2 dimensions such as 'Sm'
%       dim must be a numeric input. cells are not accepted
% 
% Example: I want to find all variables Pg concerning the third generator
%          my_tongs(full_idx, 'var', 'Pg', -1, 3)
% 
%          I want to find all variables Pg concerning the 4th generator, for j=1, for all t and all k
%          my_tongs(full_idx,'var','Pg', [2, -1],[1,4]);
% 
%          I want to find all Sp constraints concerning second storage device
%          my_tongs(full_idx,'lin','Sm',-1,2);
% 
% If the first input was an opt_model (om object) instead of full_idx, i can easily call get_full_idx on it
% however, if i'm going to call my_tongs several times, then i'd better just get_full_idx once 
% outside and before my_tongs; because get_full_idx itself is time consuming

if 0 %depricated
error('Depricated');
nt = most1.idx.nt;

vars_names = fieldnames(most1.om.var.idx.i1);
cons_names = fieldnames(most1.om.lin.idx.i1);
cost_names = fieldnames(most1.om.qdc.idx.i1);

%{
%for an incomplete list of all variables' names, see MOST manual, page 69 ;)

u variables: on/off status
v variables: startup events
w variables: shutdown events
Pg: generator output
Psc: storage charing
Psd:x storage discharing

There will be multiple Pg, distinguished by indices between paranthesis (sounds cool). for exmaple: Pg(2,5,10)
the first index is the time period. in this case, this Pg belongs to second time period
the second index is number of wind scenarios. in this case, this Pg belongs to 5th wind scenario for the 2nd time period
third index is number of contingencies (if modelling explicit SCOPF). in this case, this Pg corresponds to the 10th contingency occurring if the system was operating in the 5th wind scenario of the 2nd period
and then this Pg(2,5,10) is not a scalar. it is a vector whose length is number of generators ng.
%}
var_idx_struct = [most1.om.var.idx.i1,most1.om.var.idx.iN,most1.om.var.idx.N];
con_idx_struct = [most1.om.lin.idx.i1,most1.om.lin.idx.iN,most1.om.lin.idx.N];

for iter_field = 1:numel(vars_names)
var_idx_table.(vars_names{iter_field}) = array2table([var_idx_struct.(vars_names{iter_field})],'VariableNames',{'i1','iN','N'});
% idx_table.(vars_names{iter_field}) = [idx_struct.(vars_names{iter_field})]; %[i_start, i_end, i_end-i_start+1]
end

for iter_field = 1:numel(cons_names)
for iter_field2= 1:size(con_idx_struct(1).(cons_names{iter_field}),2)
con_idx_table.([cons_names{iter_field},'_',num2str(iter_field2)]) = array2table([con_idx_struct(1).(cons_names{iter_field})(:,iter_field2),con_idx_struct(2).(cons_names{iter_field})(:,iter_field2),con_idx_struct(3).(cons_names{iter_field})(:,iter_field2)],'VariableNames',{'i1','iN','N'});
% idx_table.(vars_names{iter_field}) = [idx_struct.(vars_names{iter_field})]; %[i_start, i_end, i_end-i_start+1]
end
end

var_indices = @(which_field) cell2mat(arrayfun(@(i) [var_idx_table.(which_field).i1(i):var_idx_table.(which_field).iN(i)]',[1:size(var_idx_table.(which_field),1)],'un',0));
con_indices = @(which_field) cell2mat(arrayfun(@(i) [con_idx_table.(which_field).i1(i):con_idx_table.(which_field).iN(i)]',[1:size(con_idx_table.(which_field),1)],'un',0));

n_vars = most1.om.var.N;
n_constraints = most1.om.lin.N;
constraints_names = fieldnames(con_idx_table);
vars_names = fieldnames(var_idx_table);
end

narginchk(5,5);
assert(ischar(field),strjoin(['2nd input must be a name (character array), one of the following: ',fieldnames(full_idx)']));
assert(ischar(name),strjoin(['3rd input must be a name (character array), one of the following: ',fieldnames(full_idx.(field))']));
assert(isnumeric(dim),'4th input must be a single number. Currently I don''t support multiple dimensions');
assert(isnumeric(idx),'5th input must be a single number. Currently I don''t support multiple dimensions');
assert(numel(unique(dim)) == numel(dim),['Duplicates exist in the 3rd input.',newline,'You can''t check the same index for different values;',newline,'If you want to extract several cases, run my_utensils separately for each']);
assert(numel(idx)==1 || (numel(dim)==numel(idx)),'Number of entries in the 4th input must be 1, or the same number in the 3rd input');

% first_occur = find(contains(full_idx.(field).full_list(:,end),name),1);
first_occur = full_idx.(field).full_order.(name)(1);
full_idx.(field).full_list(first_occur,end);
n_idx = count(full_idx.(field).full_list(first_occur,end),',')+1;
str = repmat({'\d+'},1,n_idx);

if numel(idx)==1
idx = repmat(idx,1,numel(dim));
end

for iter_dim=1:numel(dim)
if dim(iter_dim)<0
dim(iter_dim) = n_idx + dim(iter_dim) + 1;
end
str{dim(iter_dim)} = num2str(idx(iter_dim));
end

str_final = ['(',name,'\(',strjoin(str,','),'\))'];
my_tokens = regexp(full_idx.(field).full_list(:,end),str_final,'tokens');
muffin = find(~cellfun(@isempty,my_tokens));
end